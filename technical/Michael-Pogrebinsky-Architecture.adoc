= Michael Pogrebinsky Architecture
:toc: left
:toclevels: 5
:sectnums:
:sectnumlevels: 5

NOTE: NOTE

TIP: TIP

IMPORTANT: IMPORTANT

CAUTION: CAUTION

WARNING: WARNING

[cols="1,3"]
|===
| Name | Description

| Asciidoctor
| Awesome way to write documentation

|===

== Software Architecture & Design of Modern Large Scale Systems Michael Pogrebinsky

*Maximizing Value*

* [ ] *Fundamentals*: Learn the concepts
* [ ] *Information*: Do POC from the course
* [ ] *Skills*: Use / Implement it in Project
* [ ] *Innovation / Expert*: Value for next 2 Years


*Objective*

* [ ] *History*:
* [ ] *Agenda-While doing this course what is the Agenda [1,2,3,4,5..]*:
* [ ] Exam Notes
* [ ] *Why OneNote Notes*:
* [ ] *What is Pending*:


---

* History:
* Agenda-While doing this course what is the Agenda:
** 18.May.2022
*** 1st Iteration. Make important information as *bold* and #yellow highlight#
*** Focus on KeyBank Interview
*** After completing the course, work with Jonathan Levi

* Exam Notes
* *Why OneNote Notes*:
* *What is Pending*:

=== Section 1: Introduction

==== Introduction to Software Architecture

Welcome to the first lecture. In this lecture, we're going to get an introduction to software architecture and also learn why software architecture is so important. After that we will define more formally and explain what software architecture means for us in the context of this course. And finally, we'll discuss where software architecture fits in the overall picture of the software development cycle. So let's start with some analogies from outside the software world which will give us a good intuition of what software architecture means to us.

Everything we build has a structure, whether we know about it or not, and whether we thought about it ahead of time or arrived at it spontaneously. The more we invest in building a product, the harder it becomes to change its structure after the fact. But what is the importance of a structure, and why would we want to change it at all in the future? Well, the thing is *the structure of our system describes both the intent of our product and its qualities*. For example, if we look at the architecture of a theater we see that its intent is to have shows and performances, but if we make people live or work in a theater instead of in a suitable house or an office they would find themselves very uncomfortable, and would have a terrible experience. On the other hand, if we look at the architecture of a residential home, we see that it would be perfect for people to live there, but hosting big shows or performances would not work very well.

Now when it comes to software, the same principles apply. There's almost an infinite number of ways for us to organize our code to achieve the functionality of the system, but different organizations will give us different properties. *In other words, the software architecture impacts how our product will perform and scale how easy it will be for us to add new features and grow our engineering team, and also how well it's going to respond to failures or security attacks*. And similarly to physical structures, if we organize our software in a suboptimal way the cost of a redesign will be significant, both in terms of time and money, especially so when we're working on a large scale system. So now that we have some basic intuition and motivation for software architecture let's define it a bit more formally so we know exactly what we're talking about when we use this term. Now, there are many ways define software architecture, and for many years people have been arguing about the best way to define it. So in our course, the definition we're going to use is as follows,

*the software architecture of a system is a high level description of the system structure, it's different components, and how those components communicate with each other to fulfill the system's requirements and constraints*. It's a heavily loaded definition, so let's unpack it piece by piece. The first part of the definition states that the software architecture is a high level description of the system.


It means that it's an abstraction that shows us the important components that help us reason about the system while hiding the implementation details out of the view. This implies that things like technologies or programming languages we use to implement the system are not part of the software architecture, and are part of the implementation instead. *This is an important point because many engineers falsely assume that software architecture is just about picking the right technologies or frameworks. This could not be further from the truth, and in fact, we want to delay making these choices until the very end of our design*. The second part of the definition talks about the different components and how they communicate with each other. The components that we're talking about when we talk about software architecture are black box elements that are defined by their behavior and APIs. As a matter of fact, those components may themselves be complex systems that are described through their own software architectural diagrams. So in a sense, this definition may be recursive when needed. Finally, the last part of the definition talks about fulfilling the system's requirements and constraints, which means that the software architecture should describe how all those components are coming together to do what the system must do, which is basically our requirements, and how the system does not do what it shouldn't do, which is described in the *system constraints*.

We're going to talk about all those components in great detail throughout the course, but I think having this definition upfront is going to set the stage for what we're going to learn in the following lectures. Now when it comes software development, we can talk about software architecture on many different levels of abstraction, starting from the lowest level abstractions like different classes or structs, depending on the programming language, and the organization, and communication between objects inside a program. We can also go one level up and talk about modules, packages, or libraries, and how they interact with each other. But since in this course we're going to be focusing on large scale systems, we're going to talk about a higher level abstraction where the individual components are separate services that run as individual processes or groups of processes potentially on different computers. It turns out that taking this more distributed multi-service approach allows us to architect systems that can handle large amounts of requests, process, and store very large amounts of data, and serve thousands, hundreds of thousands, or even millions of users every day. A few examples of such systems include online software services such as ride-sharing, video-on-demand, social media, online video games, investing services and banks, and many, many others. *When we set our goal to build a product that operates on such a scale, getting the architecture just right can mean going from a small start-up to a multi-billion dollar company and making a positive impact on millions of people all around the world*. On the flip side, if we don't do a good job at the design phase we can potentially waste months of engineering time building a system that doesn't meet our requirements and that nobody wants to use. And restructuring a system that was not architected correctly is very hard and expensive. So as we can see, the stakes here are high, which makes what we're going to learn in this course super important.

Now before we conclude this lecture, I want to talk about one last thing which is the place where software architecture fits in the overall picture. *Software development can roughly be described in four phases, design, implementation, testing, and deployment*. Since generally software products keep evolving over a long period of time, those four phases can be repeated many times, where arguably the first iteration is the most critical, and subsequent iterations make incremental changes to the existing system. Now something that I already alluded to but didn't state formally is that software architecture is the output of the design phase phase, and the input to the implementation phase. In this course, we're going to focus on arguably the most important step, which is the design phase. The design phase is essentially a process of defining the software architecture of the system that an entire team or even multiple teams of engineers later proceed to implement, sometimes over a course of multiple weeks or months. Now there are many challenges of defining a good software architecture for our system but the biggest challenge that software engineers struggle with the most is the fact that unlike an algorithm or a formula that can be proven to be both correct and optimal, we can't do the same for software architecture. *So to guarantee our success, what we can do is follow a methodical design process as well as apply industry proven architectural patterns and best practices, which is what we're going to learn throughout the course*. But before we proceed to the first topic, let's quickly summarize what we learned in this lecture.

In this lecture, we got the intuition and motivation for software architecture. We learned that every software system has an architecture which is basically its structure, and its structure is absolutely critical for its success. We later define software architecture more formally as a high level description of the system structure, it's different components, and how those components communicate with each other to fulfill the system's requirements and constraints. And we concluded with placing software architecture in the overall software development cycle as the output of the design phase and the input to our systems implementation. So now that we got a solid introduction to what we're going to learn, let's go ahead and start learning the first topic of the course.

=== Section 2: System Requirement and Architectural Drivers

==== Introduction to System Design & Architectural Direct Drivers

Welcome back. In this lecture, we're going to talk about gathering, classifying and analyzing requirements as the first step in designing a large scale system. But before we get into any details, let's first get some motivation. System requirements is just a formal word for figuring out and narrowing down what exactly we need to build for our client. As software engineers, we shouldn't be new to receiving informal requirements for the task we need to accomplish. But when it comes to the design of a large scale system, there are a few differences from the usual requirements we are used to getting for implementing a method, an algorithm or a class. The first difference is the scope and level of obstruction of the requirements and especially the solution we need to design. For example, when we're tasked to implement a method or an algorithm in an existing code base, we typically know what the input and output look like. We are also somewhat limited to the programming languages we're going to use. *As we go up to a more high level obstruction like designing a class, a module, a library or an application, the range of possible ways to solve the problem becomes bigger and bigger as we have more degrees of freedom*. Also the scope of the problem becomes so high that it's hard for us to even visualize the implementation. #*So when we are asked to design an entire system we may feel so overwhelmed that we may not even know where to begin*#. For example, imagine you are asked to design a file storage system, a video streaming solution, or a ride sharing service, it needs to scale to serving millions of users per day. It's hard not to get overwhelmed by such a task. *The second challenge and difference from what we're normally used to is the level of ambiguity*. The reason for this ambiguity is twofold. *First of all, in many cases, the requirements are not even coming from an engineer, and sometimes they're not even coming from a very technical person. So the client or product manager may ask for something very high level. And it's our responsibility to transform those requests into precise and technical requirements*. Those technical requirements will serve as the foundation for building our software architecture. *The second reason for* the high level of ambiguity is getting the specific requirements is already part of the solution. This may seem a little odd for us at first, *but we have to remember that the client doesn't always know exactly what they need. The only thing they know for sure is the problem they need to solve*. To demonstrate this, let's take a specific example.

Let's say we're asked to design a hitch hiking service that allows people to join drivers that are already driving on a particular route, and are willing to take passengers on their way for a fee. That may be all the requirements we get from the client, and it is up to us to ask things like, is it going to be a real time service or the riders will have to contact the drivers in advance, is it going to be a mobile or desktop experience or maybe both, are we going to enable payment through our system or the riders will have to pay the drivers directly? In some cases, the client may not even know the answer to those questions right away until we actually ask those questions.

*That is why in most system design interviews, one of the things being tested is our ability to clarify and ask those questions ahead of time*. Because as we can see, asking those questions and gathering those requirements is already part of the solution and it greatly narrows down what we need to design and build. Now, what happens if we don't get all the requirements right? Can't we just do it incrementally? Why can't we simply build something and see if it satisfies the client? And if it doesn't, no big deal. We can just fix it, can't we? After all, we're not building a building or a bridge here. There's similarly no big cost of materials in software, like in mechanical engineering, for example, or construction of a building. Well, the mental leap we need to make here from small projects like building a method or a few classes where we can easily rewrite the code many times until we get it right, large scale systems are big projects that cannot be changed easily overnight. Those projects take many engineers, sometimes even multiple teams of engineers. They can take months to build, which makes the cost of engineering time very significant. They also often require purchasing hardware and sometimes software licenses upfront. And those projects typically involve contracts with time commitments and financial obligations. Also not delivering the product to our clients or users on time may cause irreversible damage to our company's reputation and brand image, so getting the requirements right upfront is absolutely critical.

So now that we got the motivation for system requirements, let's take a step further and learn to *classify the requirements into a few categories*, which have completely different effects on our architecture and design. *The three main types of requirements are features of the system, also known as functional requirements, quality attributes, which are also known as non-functional requirements, and system constraints, which basically the limitations and boundaries of the system*.

Let's start talking about the first type of requirements, the features of the system. Those requirements essentially describe the system's behavior. In other words, what the system we're designing actually does. Those requirements are easily tied to the objective of the system. They are also called functional requirements because they essentially describe our system as a black box function. The user's input or external events are the inputs to that function, and the result or outcome of the operation taken by our system is the output of that function. It's important to point out that the features or functional requirements simply dictate the functionality of our system but do not determine its architecture. And generally any architecture can achieve any feature, which is what makes our job as software architects so difficult. Now, let's look at a few examples of features or functional requirements in our hitchhiking service example. One functional requirement can be as follows, when a rider logs into our mobile app, the system must display a map with nearby drivers within five miles radius. Here the input to our system is the user's login action, and the output is the view of a map with nearby drivers. Let's take another example. When the ride is complete, the system will charge the rider's credit card and transfer that money to the driver minus some service fees. Here the completion of the ride is the input event, and the transfer of the money is the outcome of the operation. Now, let's talk about the second type of requirements, the quality attributes or non-functional requirements. The quality attributes are properties that the system must have as opposed to what the system must do. Examples of such qualities include scalability, availability, reliability, security, performance, and this list can go on and change depending on the system. In contrast to the functional requirements, the quality attributes do dictate the software architecture of our system. Another way to look at this is, the software architecture defines the system quality attributes. And different architectures provide us with different quality attributes. The last type of requirements is *system constraints*. A few examples include strict deadlines, limited budget, or a small number of engineers that can work on our project. Such constraints may force us to make certain trade offs and sacrifices in our design and shift us towards certain software architectural decisions that we would not make if we didn't have those constraints. The three types of requirements that we learned in this lecture are also sometimes referred to as architectural drivers. Because they essentially drive our architectural decisions from an infinite universe of possibilities towards one solution that satisfies our clients' needs. In this lecture, we learned about the importance of requirements in the design of large scale systems. We discussed the few challenges of gathering those requirements, such as the large scope and ambiguity that we may not be familiar with coming from a smaller scale programming world. After that, we talked about the risks of not getting those requirements correctly upfront. And finally, we classified those requirements into three groups, which are also called the architectural drivers of the system. Those three groups are the features of the system, the quality attributes and the systems constraints. See you guys all in the next lecture.

---
We received the following requirement from the client:

"We would like you to build a system that allows sharing large files between users.

After a user uploads a file they will get a unique link that they can share with other users. Any user with that link can download the file.

The link should become active no later than 1 second after the file was uploaded. Download speeds should be at least 50 Mbit/sec.

You have to support at least PDF, and JPG file formats, as well as the following web browsers: Google Chrome, Mozilla Firefox, Microsoft Edge."

---

==== Feature Requirements - Step by Step Process

Welcome back. In this lecture, we're going to continue our discussion about systems requirements and learn about a formal step by step method together and visualize the functional requirements of our system. So let's go ahead and learn about a step by step way to capture all the functional requirements of our system. In the previous lecture, we talked about the importance of gathering all the requirements for our system before starting designing our system architecture. And we also talked about the challenges in capturing those requirements which involve ambiguity as well as the large scope.

So one native way we can go about it, is to just ask the client to describe everything they need our system to do hoping that they do not forget any detail. However, for complex systems with many features and multiple actors involved, this is not a good approach. *A more powerful and methodical way of gathering requirements and capturing the important features of the desired system, is through use cases and user flows*. A use case is a particular situation or scenario in which our system is used to achieve a user's goal. *A user flow is a more detailed step by step or graphical representation of each such use case*. So the steps in capturing all the functional requirements in a formal way are as follows: *first*, we need to identify all the actors or users in our system otherwise we will likely not capture all their relevant use cases. The *second step* is to describe all the possible use cases or scenarios in which an actor or user can use our system. And finally, the *third step* is to take each use case and expand it through a flow of events or interactions between the actor and our system and in each event in this interaction we *capture the action and also take note of the data that flows with it to, and from our system*.

If we continue with the hitchhiking service example we mentioned in the previous lecture, that allows people to join drivers that are already driving on a particular route and are willing to take passengers on their way for a fee in this case, we only have two actors, the driver willing to take passengers and the rider. *Now, let's take the second step* and find all the use cases where a driver or a rider interacts with our hitchhiking service. For example, one use case is the registration of a new rider to our system the first time. Similarly, we have a registration of a new driver to our service, it's another use case. Another use case is logging in of an existing user to our system to initiate a ride. Similarly, we have the use case where a driver logs in and is willing to pick up a rider. Then we have a successful match between a rider and a driver, which starts and completes a ride and finally, we have the use case where we an unsuccessful match where in other words, a rider could not find a driver that is willing to pick him up. Of course, these are not all the use cases but we get the idea.

Now let's walk through an example of expanding the most interesting use case of a successful match between a rider and a driver. There are many ways we can represent the flow of actions in a user flow, the way we're going to represent it is through what's called a *sequence diagram.* Generally, a sequence diagram is a type of diagram that represents the interactions between actors and objects. This type of diagram is part of a Unified Modeling Language which is a standard for visualizing system design. It's important to point out that in practice, UML diagrams are used mostly for software design and there is no real standard for representing software architecture in a high level. Furthermore, UML as a language is not strictly followed in the industry but sequence diagrams are still frequently used to represent interactions between different entities in the system and not just objects. In a sequence diagram, the time goes from top to bottom and each entity is represented as a vertical line. The communication between the entities is represented by arrows, going from one entity to another entity while responses are represented as broken lines going from the destination entity to the caller entity. So now let's walk through an example of expanding the most interesting use case from the hitchhiking service the one that are represents a successful match and the ride starting with the ride initiation and define its entire user flow in the sequence diagram. We start with particular driver that already logged into our service and makes a call to our system that they are on a particular route and they're ready to pick up a rider.

Then a rider who's also already logged into our system sends us a message telling us about his origin, destination and also that they're looking for a driver to pick them up. Please note that in this diagram, we're not going to indicate the data that is sent in each message but we will take note of that data for the future. Now at this point, our system tries to match that rider to an existing driver and if a match found, both the rider and the driver are notified. And finally when the driver makes his way to the rider's location and picks him up, they will start the ride also at that point, the rider will be notified that the ride has began as a form of confirmation. Now let's fast forward to the point where the driver arrives at the destination and finishes the ride and when that happens a message is sent to our system. Once we get this message, our system charges the rider from their bank account and sends the receipt to the rider. After that our system takes a portion of that charge as a service fee and credits the driver's account with the rest of the money from the rider. Finally, the driver is notified about the new credit in their account. Now a great side benefit of capturing all those interactions between the actors in our system as part of our user flow is that we can easily take this user flow and identify the future API of our system because essentially each interaction is an API call between an actor and our system and the data flowing between those actors and our system is essentially the arguments in those API calls. But we'll talk about designing APIs in a different lecture. In this lecture, we learned about a formal way to capture and document all the features and functional requirements of our system. This formal three step process involves identifying all the users and actors, gathering all the use cases where the actors interact with our system, and finally expanding upon each use case by describing the entire flow of interactions between the actors in our system. Also, we learned a way to visualize those interactions using a very common and useful diagram called sequence diagram. See you guys all in the next lecture.