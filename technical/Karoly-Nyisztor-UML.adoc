= Karoly Nyisztor UML
:toc: left
:toclevels: 5
:sectnums:
:sectnumlevels: 5

NOTE: NOTE

TIP: TIP

IMPORTANT: IMPORTANT

CAUTION: CAUTION

WARNING: WARNING

[cols="1,3"]
|===
| Name | Description

| Asciidoctor
| Awesome way to write documentation

|===


== UML and Object-Oriented Design Foundations

=== Section 1: Introduction

==== Whatâ€™s Covered in this Course?

Hi, I'm Karoly Nyisztor and welcome to my course UML and Object-Oriented Design foundations. The main goal of my course is to avoid the situation when you stare at your favorite IDE without knowing what to do next. Let's first talk about the motivation behind studying UML. After learning the basic syntax of a programming language, we usually start writing some code. Eventually, we realize that creating real-world applications requires additional skills. Mastering the syntax of a programming language is not enough. *We must also know how to design the software system by applying common object-orientation principles - and we must be able to describe our design so that others can understand it clearly*. *The Unified Modelling Language provides a standard set of visual symbols and diagramming techniques. Using UML, we can sketch our systems easily*. This course is all about UML and software design related concepts. Now, the steps required to create a software system are not carved in stone. Yet, attempts have been made to formalize the process. We're going to discuss the Waterfall and the Agile approach. Object-orientation has been around since the 80s, but its principles are still valid and used in modern software design. I dedicated an entire section to the fundamental object-orientation concepts. Next, you will learn about the various steps of the object-oriented software analysis and design process. Mastering these concepts will let you design your software systems more efficiently. Then, we'll dive into UML. This UML introduction will make it easier for you to understand the upcoming detailed lectures. Next, I'll introduce the most popular UML diagram types. We start with the use case diagram that lets us describe the requirements in a formal way. Then we discuss the class diagram. Class diagrams can model the main types that form a system and the relationships between them. We'll also talk about sequence diagrams that can be used to represent the dynamic behavior of your objects. We will then discuss the activity and the state diagram. To solidify the concepts you learned, I'm going to walk you through the steps of designing a note-taking application. We'll start by collecting the requirements, and then we'll create the use case diagrams. After identifying the main entities, we'll model the class diagrams. You're also going to see the sequence and the state diagram in action. All right, we've got lots of exciting things to cover. So, let's move on.

==== Tools and Prerequisites

Now, before starting the course, you should be aware of some prerequisites. This course is beginner friendly. I explain each concept clearly and illustrate it using practical examples. So, you don't have to be an expert by any means, but you should have at least fundamental programming knowledge. I'll be using basic concepts like, for example, conditions, functions, loops, and I assume you understand them. Download *StarUML* if you want to follow along with me the creation of the UML diagrams in this course. It is available for Mac, Linux and Windows at *staruml.io*. Although we won't be writing any source code, I'll show you some code examples. I use *Atom*, a free and open source text and source code editor developed by GitHub. It is available on atom.io, and it runs on Mac OS, Linux, and Microsoft Windows. All right, let's get started.

=== Section 4: Object-Oriented Analysis and Design

==== Fundamental Object-Oriented Analysis and Design Concepts

Building an object-oriented application requires some preliminary steps. These steps are similar regardless of the development methodology. First, we need to collect the requirements. During the requirements collection phase, we answer the following questions: What's the problem we're trying to solve? What does our app or framework need to do to accomplish that functionality? The requirements collection step involves a lot of brainstorming and discussion. Once we come to an agreement, we need to document our ideas. The requirements need to be as clear as possible. Only write down the decisions that underline what the system is going to do. Vague thoughts will lead to conflicts later on. Once the requirements are clear, we come up with a description of the software system. We should describe the app from the user's perspective. Depending on the project, we may pick an Agile or a Waterfall methodology. *For Agile projects, it is completely fine if we don't provide an accurate description*. We can still fill the gaps or refine our thoughts later on. The point here is to gain as much clarity as needed to start the next step. *The step of describing the app may include the creation of visual mockups, wireframes, or even prototypes*. If it helps in communicating your thoughts to the client, then do it. *I've used wireframes and nonfunctional prototypes for most of my projects*. *These prototypes proved to be extremely useful, especially if the client was not familiar with the platform or they had no specific expectations*. Let's say a customer asks you to create an iOS version of their Android app. A prototype will help the client understand that the iOS version will look and behave differently. By communicating our vision precisely, we avoid surprises and misleading expectations. *Next comes the third phase. During this step, we aim to identify the things that form our system.* These are the potential players that have a specific, well-defined role in our application. Picking the essential entities won't be challenging if we did a good job during the previous two steps. We'll realize that we need a class that represents, say, an item that has a name, a price and some other attributes, or a class responsible for securely communicating with the server. Another class may manage your local persistence, and so on. In the final phase, we describe the behavior of our system in a formal way. This last step is about creating visual representations of our classes, their attributes and behavior. We also model the interaction between the objects. We rely on the Unified Modeling Language, or UML for short. UML is a form of graphical notation that provides a set of standard diagrams. These diagrams let us describe object-oriented systems in a standard way. I know, this may sound overwhelming now, but don't worry. We're going to discuss each of these concepts in the upcoming lectures.

==== Collecting Requirements

The initial step of building a software system is crucial. It's often called requirement-collection phase or requirements analysis. But regardless of what we call it, it paves the way for all the other phases of the object-oriented software design. Requirement means "a thing that is needed or wanted." And that's exactly what we need to focus on during this initial step: we must clarify what's needed or wanted in our application. The features of the system are the so-called functional requirements. Functional requirements represent what the app needs to provide feature-wise, how it should react to a particular input, or what the expected behavior is in a specific situation. Let's say you are about to develop an app for runners. You should answer questions like the following: Should the actual speed always be visible on the main screen? Do we allow imperial or metric units? Should we make this configurable by the user or automatically adjust the units based on the phone's settings instead? We'll also usually have non-functional requirements. These are the requirements that are not directly related to a feature or behavior of the software system, but are important nonetheless. Think of performance requirements- you don't want to ruin the user experience with an unresponsive app. You also may need to address legal requirements. Does the app collect sensitive user data? Does it allow users to browse the Internet? Documentation and support are other non-functional requirements. Your software may need to adhere to certain standards or regulations. Nonfunctional requirements are equally important. Ignoring them may cause serious legal issues and all sorts of other problems. Now, how do we handle this? There are different ways to gather the requirements. The easiest way is just to write them down. Here's an example from a project I've been working on. Functional requirements: the app must store travel expenses organized by trip. Each trip must have a home currency. The default currency is fetched from the phone's settings. User settings must override the default home currency. Expenses can be entered in any of the supported currencies. The app must automatically convert the amounts to the home currency. Nonfunctional requirements. The app must run on iOS 9 and newer versions. The app must avoid unnecessary network roundtrips to reduce data roaming fees and preserve battery. The app must include the support email and the link to the app's website. These are short, concise phrases in the form: "The app or system must do this or that." You don't want to write lengthy descriptions. And feel free to adapt this format to your needs. You should eventually capture your requirements digitally, but at early stages, pen and paper or a whiteboard are also fine. Just make sure you save them somehow - by taking a photo, for example. There are also more formal ways, tools, and systems that support the requirements collection step. I won't talk about these tools because this course is not about tools, but rather about principles. To summarize, the requirements collection step boils down to this: We need to formulate what our software must do and which are the constraints and boundaries we need to consider. If we are using a Waterfall approach, we need to clarify all the requirements in advance. For agile projects it's perfectly acceptable if we continue without having all the answers. We may even miss some of the questions. Agile lets us revisit and refine the requirements as we iterate through the software development process.

